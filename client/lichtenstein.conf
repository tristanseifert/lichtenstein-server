################################################################################
# this is a simple config file for testing purposes. all paths fall in the
# working directory.
################################################################################

################################################################################
# Logs can be sent to a file, the console, and syslog; or a combination of all
# three of these. It is possible to specify per source the minimum message
# level: 0 = trace, 1 = debug, 2 = info, 3 = warn, 4 = error, 5 = critical
logging: {
    # Logging to file
    file: {
        # Whether logging to a file is enabled
        #
        # Default: false
        enabled = true;

        # Path to the logfile
        #
        # Default: None
        path = "./lichtenstein.log";

        # The log file can be truncated on open.
        #
        # Default: false
        truncate = false;

        # Minimum log level that will be written to the log file
        #
        # Default: 2 
        level = 0;
    }

    # Logging to console
    console: {
        # Whether logging to the console is enabled
        #
        # Default: true
        enabled = true;

        # When enabled, console output can be colorized with ANSI escape codes.
        #
        # Default: false
        colorize = true;

        # Minimum log level that will be displayed on the console.
        #
        # Default: 2 
        level = 0;
    }

    # Logging to syslog
    syslog: {
        # Whether logging to syslog is enabled
        #
        # Default: false 
        enabled = false;

        # Syslog ident to use
        #
        # Default: "lichtenstein"
        ident = "lichtenstein";

        # Syslog facility to tag the logs with. This can be one of the standard
        # facility names; see man 3 syslog for more info.
        #
        # Default: local0
        facility = "local0";

        # Minimum log level that will be sent to syslog
        #
        # Default: 2 
        level = 2;
    }

    # Configuration for the asynchronous logging queue
    queue: {
        # Size of the queue used for async logging. Each entry in the queue is
        # about 256 bytes on x86_64.
        #
        # Default: 8192
        size = 8192;

        # Number of async logging threads to use. Values other than 1 can
        # result in out-of-order messages.
        #
        # Default: 1
        threads = 1;
    }
}

################################################################################
# Node identity; it's required that the UUID is unique among all nodes
# connected to a single server, and that the secret is known to both the client
# and server.
id: {
    # Node UUID, serving as a persistent identifier of this node.
    #
    # Default: (none)
    uuid = "";

    # Shared secret, used for authenticating against the server. You should add
    # this to the server before starting the client for the first time.
    #
    # This should be 16 bytes of base64-encoded binary data.
    #
    # Default: (none)
    secret = "";
}

################################################################################
# Information about the remote server to connect to. Additional addresses, such
# as the multicast group address, are discovered automagically once we've
# connected to the server.
remote: {
    # Server address information
    server: {
        # Remote server address; this can be either an IPv4 or IPv6 address, or
        # a hostname.
        #
        # Default: (none)
        address = "";

        # UDP port to connect to.
        #
        # Default: 7420
        port = 7420;

        # Use only IPv4 addresses. This can be useful if the system has broken
        # IPv6, or there are some other reasons why you want to only use IPv4
        # when resolving server names.
        #
        # Default: false
        ipv4_only = false;
    }

    # Read timeout for the client socket. This determines how responsive the
    # client is to network failures and termination requests.
    #
    # Default: 2 (seconds)
    recv_timeout = 2.0;

    # How to verify the server's identity. We can check either that the cert
    # fingerprint matches one of the given values, or that the CN matches what
    # is specified in the address value above, and that it is issued by the CA
    # provided in the PEM file.
    cert: {
        # Certificate hashes to verify against. Only a single value needs to
        # match for the certificate to be accepted.
        #
        # Default: []
        fingerprint = [];

        # Path to a PEM-encoded CA to check the certificate against. If self-
        # signed certificates are used, you can provide the path to it here.
        #
        # Default: (none)
        ca_path = "";
    }
}

################################################################################
# Output channel configuration; multiple plugins are available, this configures
# those that cannot auto-detect channels. It also provides some general plugin
# configuration.
plugin: {
    # Path to the directory containing plugin files. These are dynamic
    # libraries, with the platform-specific extension (.dylib on macOS, .so on
    # FreeBSD,) that are enumerated and loaded on startup.
    #
    # Default: (none)
    path = "";

    # Comma-separated list of plugins to instantiate.
    #
    # Default: (none)
    plugins = "";

    # Dummy output plugin configuration
    dummy: {
        # Number of channels to advertise.
        #
        # Default: 0
        channels = 0;

        # Number of pixels per channel
        #
        # Default: 300
        pixels = 300;

        # Channel pixel format; 0 for RGB, 1 for RGBW.
        #
        # Default: 0
        format = 0;
    }
}
